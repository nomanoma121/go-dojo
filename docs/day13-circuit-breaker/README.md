# Day 13: Circuit Breakerãƒ‘ã‚¿ãƒ¼ãƒ³

## ğŸ¯ æœ¬æ—¥ã®ç›®æ¨™ (Today's Goal)

å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹ã®éšœå®³ãŒè‡ªèº«ã®ã‚·ã‚¹ãƒ†ãƒ ã«æ³¢åŠã™ã‚‹ã®ã‚’é˜²ãCircuit Breakerãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å®Ÿè£…ã—ã€ã‚·ã‚¹ãƒ†ãƒ ã®è€éšœå®³æ€§ã‚’å‘ä¸Šã•ã›ã‚‹ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã‚’å­¦ç¿’ã—ã¾ã™ã€‚

## ğŸ“– è§£èª¬ (Explanation)

### Circuit Breakerãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ã¯

Circuit Breakerãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹ã®å‘¼ã³å‡ºã—ã‚’ç›£è¦–ã—ã€å¤±æ•—ãŒä¸€å®šã®é–¾å€¤ã‚’è¶…ãˆãŸå ´åˆã«è‡ªå‹•çš„ã«å›è·¯ã‚’ã€Œé–‹ãã€ã“ã¨ã§ã€ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®éšœå®³ã‚’é˜²ããƒ‡ã‚¶ã‚¤ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã™ã€‚

### ãªãœå¿…è¦ãªã®ã‹ï¼Ÿ

1. **éšœå®³ã®é€£é–ã‚’é˜²ã**: å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹ã®éšœå®³ãŒè‡ªåˆ†ã®ã‚·ã‚¹ãƒ†ãƒ ã«æ³¢åŠã™ã‚‹ã“ã¨ã‚’é˜²ãã¾ã™
2. **ãƒªã‚½ãƒ¼ã‚¹ã®ä¿è­·**: å¤±æ•—ã™ã‚‹ã“ã¨ãŒåˆ†ã‹ã£ã¦ã„ã‚‹å‘¼ã³å‡ºã—ã‚’é¿ã‘ã€ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ¼ãƒ«ã‚„ãƒ¡ãƒ¢ãƒªã‚’ç„¡é§„ã«æ¶ˆè²»ã—ã¾ã›ã‚“
3. **é«˜é€Ÿãªå¤±æ•—**: å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹ãŒãƒ€ã‚¦ãƒ³ã—ã¦ã„ã‚‹é–“ã¯å³åº§ã«å¤±æ•—ã•ã›ã€å¿œç­”æ™‚é–“ã‚’çŸ­ç¸®ã—ã¾ã™
4. **è‡ªå‹•å›å¾©**: ã‚µãƒ¼ãƒ“ã‚¹ãŒå¾©æ—§ã—ãŸéš›ã®è‡ªå‹•æ¤œçŸ¥ã¨å›å¾©æ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™

### Circuit Breakerã®3ã¤ã®çŠ¶æ…‹

#### 1. ClosedçŠ¶æ…‹ï¼ˆé€šå¸¸çŠ¶æ…‹ï¼‰
- ã™ã¹ã¦ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹ã«è»¢é€
- æˆåŠŸãƒ»å¤±æ•—ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
- å¤±æ•—ç‡ãŒé–¾å€¤ã‚’è¶…ãˆã‚‹ã¨OpençŠ¶æ…‹ã«ç§»è¡Œ

#### 2. OpençŠ¶æ…‹ï¼ˆå›è·¯é–‹æ”¾çŠ¶æ…‹ï¼‰
- ã™ã¹ã¦ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å³åº§ã«å¤±æ•—ã•ã›ã‚‹
- å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹ã¸ã®å‘¼ã³å‡ºã—ã¯è¡Œã‚ãªã„
- ä¸€å®šæ™‚é–“çµŒéå¾Œã«Half-OpençŠ¶æ…‹ã«ç§»è¡Œ

#### 3. Half-OpençŠ¶æ…‹ï¼ˆå›å¾©è©¦è¡ŒçŠ¶æ…‹ï¼‰
- é™å®šæ•°ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ã¿å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹ã«è»¢é€
- æˆåŠŸã™ã‚Œã°ClosedçŠ¶æ…‹ã«æˆ»ã‚‹
- å¤±æ•—ã™ã‚Œã°OpençŠ¶æ…‹ã«æˆ»ã‚‹

### å®Ÿè£…ã«ãŠã‘ã‚‹è€ƒæ…®ç‚¹

#### ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•æ€§
è¤‡æ•°ã®goroutineã‹ã‚‰åŒæ™‚ã«ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã‚‹ãŸã‚ã€å†…éƒ¨çŠ¶æ…‹ã®ç®¡ç†ã«ã¯é©åˆ‡ãªåŒæœŸå‡¦ç†ãŒå¿…è¦ã§ã™ã€‚

#### çµ±è¨ˆã®ç®¡ç†
å¤±æ•—ç‡ã®è¨ˆç®—ã«ã¯æ»‘å‹•çª“ï¼ˆsliding windowï¼‰ã‚’ä½¿ç”¨ã—ã€ç›´è¿‘ã®ä¸€å®šæœŸé–“ã§ã®æˆåŠŸãƒ»å¤±æ•—ã‚’ç®¡ç†ã—ã¾ã™ã€‚

#### ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®š
å„çŠ¶æ…‹ã§ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®šã‚’é©åˆ‡ã«ç®¡ç†ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼š
- ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
- OpençŠ¶æ…‹ã§ã®å¾…æ©Ÿæ™‚é–“
- Half-OpençŠ¶æ…‹ã§ã®è©¦è¡Œæ™‚é–“

## ğŸ“ èª²é¡Œ (The Problem)

ä»¥ä¸‹ã®æ§‹é€ ä½“ã¨ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ã€Circuit Breakerãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å®Œæˆã•ã›ã¦ãã ã•ã„ï¼š

```go
// ã€çŠ¶æ…‹å®šç¾©ã€‘Circuit Breakerã®3ã¤ã®åŸºæœ¬çŠ¶æ…‹
type CircuitBreakerState int

const (
    StateClosed   CircuitBreakerState = iota  // ã€é€šå¸¸çŠ¶æ…‹ã€‘å…¨ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’è»¢é€
    StateOpen                                 // ã€é–‹æ”¾çŠ¶æ…‹ã€‘å…¨ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å³åº§ã«æ‹’å¦
    StateHalfOpen                            // ã€åŠé–‹çŠ¶æ…‹ã€‘é™å®šçš„ã«ãƒªã‚¯ã‚¨ã‚¹ãƒˆè»¢é€ã‚’è©¦è¡Œ
)

// ã€æ ¸å¿ƒå®Ÿè£…ã€‘Circuit Breaker ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å®Œå…¨å®Ÿè£…
type CircuitBreaker struct {
    // ã€è¨­å®šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã€‘ã‚·ã‚¹ãƒ†ãƒ è¦ä»¶ã«å¿œã˜ã¦èª¿æ•´
    maxFailures      int           // ã€é–¾å€¤ã€‘OpençŠ¶æ…‹ã¸ã®ç§»è¡Œåˆ¤å®šï¼ˆä¾‹ï¼š5å›é€£ç¶šå¤±æ•—ï¼‰
    resetTimeout     time.Duration // ã€å›å¾©æ™‚é–“ã€‘Openâ†’HalfOpenç§»è¡Œã¾ã§ã®å¾…æ©Ÿæ™‚é–“ï¼ˆä¾‹ï¼š30ç§’ï¼‰
    halfOpenMaxCalls int           // ã€è©¦è¡Œå›æ•°ã€‘HalfOpençŠ¶æ…‹ã§ã®æœ€å¤§ãƒªã‚¯ã‚¨ã‚¹ãƒˆæ•°ï¼ˆä¾‹ï¼š3å›ï¼‰
    
    // ã€å®Ÿè¡Œæ™‚çŠ¶æ…‹ã€‘æ’ä»–åˆ¶å¾¡ä¸‹ã§ç®¡ç†ã•ã‚Œã‚‹å‹•çš„çŠ¶æ…‹
    state         CircuitBreakerState  // ã€ç¾åœ¨çŠ¶æ…‹ã€‘Closed/Open/HalfOpenã®çŠ¶æ…‹ç®¡ç†
    failures      int                  // ã€å¤±æ•—ã‚«ã‚¦ãƒ³ãƒˆã€‘é€£ç¶šå¤±æ•—å›æ•°ã®è¿½è·¡
    lastFailTime  time.Time            // ã€æœ€çµ‚å¤±æ•—æ™‚åˆ»ã€‘OpençŠ¶æ…‹ã‹ã‚‰ã®å›å¾©åˆ¤å®šç”¨
    halfOpenCalls int                  // ã€è©¦è¡Œã‚«ã‚¦ãƒ³ãƒˆã€‘HalfOpençŠ¶æ…‹ã§ã®å®Ÿè¡Œæ¸ˆã¿å›æ•°
    
    // ã€æ’ä»–åˆ¶å¾¡ã€‘è¤‡æ•°Goroutineã‹ã‚‰ã®åŒæ™‚ã‚¢ã‚¯ã‚»ã‚¹å¯¾å¿œ
    mutex sync.RWMutex  // èª­ã¿æ›¸ãåˆ†é›¢ãƒ­ãƒƒã‚¯ã§é«˜ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’å®Ÿç¾
}

// ã€è¨­å®šæ§‹é€ ä½“ã€‘Circuit BreakeråˆæœŸåŒ–ç”¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
type Settings struct {
    MaxFailures      int           // ã€é‡è¦ã€‘é©åˆ‡ãªå€¤è¨­å®šãŒæˆåŠŸã®éµ
    ResetTimeout     time.Duration // å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹ã®å›å¾©æ™‚é–“ã‚’è€ƒæ…®
    HalfOpenMaxCalls int           // å°‘æ•°ã§é–‹å§‹ã—ã€æ®µéšçš„ã«å¢—åŠ 
}

// ã€å®Ÿè£…æŒ‡é‡ã€‘ï¼š
// 1. maxFailures: å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹ã®ä¿¡é ¼æ€§ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦è¨­å®š
//    - é«˜ä¿¡é ¼æ€§ã‚µãƒ¼ãƒ“ã‚¹: 3-5å›
//    - é€šå¸¸ã‚µãƒ¼ãƒ“ã‚¹: 5-10å›
//    - ä¸å®‰å®šã‚µãƒ¼ãƒ“ã‚¹: 10-20å›
//
// 2. resetTimeout: ã‚µãƒ¼ãƒ“ã‚¹å¾©æ—§æ™‚é–“ã¨ãƒãƒ©ãƒ³ã‚¹
//    - é«˜é€Ÿå¾©æ—§: 10-30ç§’
//    - é€šå¸¸å¾©æ—§: 1-5åˆ†
//    - é‡ã„å‡¦ç†: 5-10åˆ†
//
// 3. halfOpenMaxCalls: æ®µéšçš„å›å¾©ã®ãŸã‚ã®æ…é‡ãªè¨­å®š
//    - ä¿å®ˆçš„: 1-3å›
//    - æ¨™æº–çš„: 3-5å›
//    - ã‚¢ã‚°ãƒ¬ãƒƒã‚·ãƒ–: 5-10å›
```

### å®Ÿè£…ã™ã¹ããƒ¡ã‚½ãƒƒãƒ‰

1. **NewCircuitBreaker**: æ–°ã—ã„Circuit Breakerã‚’ä½œæˆ
2. **Call**: å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹å‘¼ã³å‡ºã—ã‚’ãƒ©ãƒƒãƒ—
3. **GetState**: ç¾åœ¨ã®çŠ¶æ…‹ã‚’å–å¾—
4. **GetCounts**: çµ±è¨ˆæƒ…å ±ã‚’å–å¾—

```go
// ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€‘Circuit Breaker ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®åˆæœŸåŒ–
func NewCircuitBreaker(settings Settings) *CircuitBreaker {
    // ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ¤œè¨¼ã€‘ä¸æ­£ãªè¨­å®šå€¤ã‹ã‚‰ã‚·ã‚¹ãƒ†ãƒ ã‚’ä¿è­·
    if settings.MaxFailures <= 0 {
        settings.MaxFailures = 5  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã§å®‰å…¨ãªå‹•ä½œã‚’ä¿è¨¼
    }
    if settings.ResetTimeout <= 0 {
        settings.ResetTimeout = 60 * time.Second  // é©åˆ‡ãªå›å¾©æ™‚é–“ã‚’è¨­å®š
    }
    if settings.HalfOpenMaxCalls <= 0 {
        settings.HalfOpenMaxCalls = 1  // ä¿å®ˆçš„ãªè©¦è¡Œå›æ•°
    }
    
    return &CircuitBreaker{
        // ã€è¨­å®šå€¤ã®æ ¼ç´ã€‘
        maxFailures:      settings.MaxFailures,
        resetTimeout:     settings.ResetTimeout,
        halfOpenMaxCalls: settings.HalfOpenMaxCalls,
        
        // ã€åˆæœŸçŠ¶æ…‹ã€‘ClosedçŠ¶æ…‹ã§é–‹å§‹ï¼ˆæ­£å¸¸å‹•ä½œãƒ¢ãƒ¼ãƒ‰ï¼‰
        state:         StateClosed,
        failures:      0,
        lastFailTime:  time.Time{}, // ã‚¼ãƒ­å€¤ã§åˆæœŸåŒ–
        halfOpenCalls: 0,
        
        // ã€æ’ä»–åˆ¶å¾¡ã€‘ä¸¦è¡Œã‚¢ã‚¯ã‚»ã‚¹ã«å¯¾å¿œ
        mutex: sync.RWMutex{},
    }
}

// ã€æ ¸å¿ƒæ©Ÿèƒ½ã€‘å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹å‘¼ã³å‡ºã—ã®å®Ÿè¡Œã¨ç›£è¦–
func (cb *CircuitBreaker) Call(fn func() (interface{}, error)) (interface{}, error) {
    // ã€STEP 1ã€‘å®Ÿè¡Œå¯å¦ã®åˆ¤å®šï¼ˆèª­ã¿å–ã‚Šãƒ­ãƒƒã‚¯ï¼‰
    cb.mutex.RLock()
    state := cb.state
    failures := cb.failures
    lastFailTime := cb.lastFailTime
    halfOpenCalls := cb.halfOpenCalls
    cb.mutex.RUnlock()
    
    // ã€çŠ¶æ…‹åˆ¥ã®å‡¦ç†åˆ†å²ã€‘
    switch state {
    case StateOpen:
        // ã€OpençŠ¶æ…‹ã€‘å›è·¯ãŒé–‹ã„ã¦ã„ã‚‹å ´åˆã®å‡¦ç†
        if time.Since(lastFailTime) >= cb.resetTimeout {
            // ã€çŠ¶æ…‹é·ç§»ã€‘ååˆ†ãªæ™‚é–“ãŒçµŒé â†’ HalfOpençŠ¶æ…‹ã¸
            cb.mutex.Lock()
            if cb.state == StateOpen { // ãƒ€ãƒ–ãƒ«ãƒã‚§ãƒƒã‚¯
                cb.state = StateHalfOpen
                cb.halfOpenCalls = 0
                log.Printf("Circuit breaker transitioning to HALF_OPEN")
            }
            cb.mutex.Unlock()
        } else {
            // ã€å³åº§ã«å¤±æ•—ã€‘å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹ã‚’å‘¼ã³å‡ºã•ãšã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™
            return nil, &CircuitBreakerError{
                Message: "circuit breaker is OPEN",
                State:   StateOpen,
            }
        }
        
    case StateHalfOpen:
        // ã€HalfOpençŠ¶æ…‹ã€‘è©¦è¡Œå›æ•°åˆ¶é™ã®ãƒã‚§ãƒƒã‚¯
        if halfOpenCalls >= cb.halfOpenMaxCalls {
            // ã€åˆ¶é™è¶…éã€‘ã“ã‚Œä»¥ä¸Šã®è©¦è¡Œã‚’æ‹’å¦
            return nil, &CircuitBreakerError{
                Message: "circuit breaker HALF_OPEN max calls exceeded",
                State:   StateHalfOpen,
            }
        }
        
        // ã€è©¦è¡Œå›æ•°ã‚’å¢—åŠ ã€‘
        cb.mutex.Lock()
        cb.halfOpenCalls++
        cb.mutex.Unlock()
        
    case StateClosed:
        // ã€ClosedçŠ¶æ…‹ã€‘é€šå¸¸å‹•ä½œã€ãã®ã¾ã¾å®Ÿè¡Œ
        break
    }
    
    // ã€STEP 2ã€‘å®Ÿéš›ã®å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹å‘¼ã³å‡ºã—
    result, err := fn()
    
    // ã€STEP 3ã€‘çµæœã«å¿œã˜ãŸçŠ¶æ…‹æ›´æ–°
    cb.mutex.Lock()
    defer cb.mutex.Unlock()
    
    if err != nil {
        // ã€å¤±æ•—æ™‚ã®å‡¦ç†ã€‘
        cb.onFailure()
    } else {
        // ã€æˆåŠŸæ™‚ã®å‡¦ç†ã€‘
        cb.onSuccess()
    }
    
    return result, err
}

// ã€å†…éƒ¨ãƒ¡ã‚½ãƒƒãƒ‰ã€‘å¤±æ•—æ™‚ã®çŠ¶æ…‹æ›´æ–°ï¼ˆè¦ãƒ­ãƒƒã‚¯ï¼‰
func (cb *CircuitBreaker) onFailure() {
    cb.failures++
    cb.lastFailTime = time.Now()
    
    switch cb.state {
    case StateClosed:
        // ã€Closed â†’ Openã€‘å¤±æ•—å›æ•°ãŒé–¾å€¤ã«é”ã—ãŸå ´åˆ
        if cb.failures >= cb.maxFailures {
            cb.state = StateOpen
            log.Printf("Circuit breaker OPENED after %d failures", cb.failures)
        }
        
    case StateHalfOpen:
        // ã€HalfOpen â†’ Openã€‘è©¦è¡Œå¤±æ•—ã«ã‚ˆã‚Šå³åº§ã«OpençŠ¶æ…‹ã«æˆ»ã‚‹
        cb.state = StateOpen
        cb.halfOpenCalls = 0
        log.Printf("Circuit breaker returning to OPEN from HALF_OPEN")
    }
}

// ã€å†…éƒ¨ãƒ¡ã‚½ãƒƒãƒ‰ã€‘æˆåŠŸæ™‚ã®çŠ¶æ…‹æ›´æ–°ï¼ˆè¦ãƒ­ãƒƒã‚¯ï¼‰
func (cb *CircuitBreaker) onSuccess() {
    switch cb.state {
    case StateClosed:
        // ã€æˆåŠŸæ™‚ãƒªã‚»ãƒƒãƒˆã€‘å¤±æ•—ã‚«ã‚¦ãƒ³ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ
        cb.failures = 0
        
    case StateHalfOpen:
        // ã€HalfOpen â†’ Closedã€‘è©¦è¡ŒæˆåŠŸã«ã‚ˆã‚Šæ­£å¸¸çŠ¶æ…‹ã«å¾©å¸°
        cb.state = StateClosed
        cb.failures = 0
        cb.halfOpenCalls = 0
        log.Printf("Circuit breaker CLOSED - service recovered")
    }
}

// ã€çŠ¶æ…‹å–å¾—ã€‘ç¾åœ¨ã®Circuit BreakerçŠ¶æ…‹ã‚’å®‰å…¨ã«å–å¾—
func (cb *CircuitBreaker) GetState() CircuitBreakerState {
    cb.mutex.RLock()
    defer cb.mutex.RUnlock()
    
    // ã€è‡ªå‹•çŠ¶æ…‹é·ç§»ã€‘OpençŠ¶æ…‹ã§ååˆ†ãªæ™‚é–“ãŒçµŒéã—ãŸå ´åˆ
    if cb.state == StateOpen && time.Since(cb.lastFailTime) >= cb.resetTimeout {
        // ã€æ³¨æ„ã€‘èª­ã¿å–ã‚Šå°‚ç”¨ãƒ¡ã‚½ãƒƒãƒ‰ãªã®ã§çŠ¶æ…‹ã¯å¤‰æ›´ã—ãªã„
        // å®Ÿéš›ã®çŠ¶æ…‹å¤‰æ›´ã¯Call()ãƒ¡ã‚½ãƒƒãƒ‰ã§è¡Œã†
    }
    
    return cb.state
}

// ã€çµ±è¨ˆæƒ…å ±ã€‘Circuit Breakerã®å‹•ä½œçµ±è¨ˆã‚’å–å¾—
func (cb *CircuitBreaker) GetCounts() CircuitBreakerCounts {
    cb.mutex.RLock()
    defer cb.mutex.RUnlock()
    
    return CircuitBreakerCounts{
        TotalCalls:    cb.getTotalCalls(),     // ç·å‘¼ã³å‡ºã—å›æ•°
        SuccessCalls:  cb.getSuccessCalls(),   // æˆåŠŸå›æ•°
        FailureCalls:  cb.failures,            // å¤±æ•—å›æ•°
        ConsecutiveFailures: cb.failures,      // é€£ç¶šå¤±æ•—å›æ•°
        State:         cb.state,               // ç¾åœ¨çŠ¶æ…‹
        LastFailTime:  cb.lastFailTime,        // æœ€çµ‚å¤±æ•—æ™‚åˆ»
    }
}

// ã€å°‚ç”¨ã‚¨ãƒ©ãƒ¼å‹ã€‘Circuit Breakerç‰¹æœ‰ã®ã‚¨ãƒ©ãƒ¼æƒ…å ±
type CircuitBreakerError struct {
    Message string
    State   CircuitBreakerState
}

func (e *CircuitBreakerError) Error() string {
    return fmt.Sprintf("circuit breaker error: %s (state: %v)", e.Message, e.State)
}

// ã€çµ±è¨ˆæ§‹é€ ä½“ã€‘Circuit Breakerã®å‹•ä½œçŠ¶æ³
type CircuitBreakerCounts struct {
    TotalCalls          int
    SuccessCalls        int
    FailureCalls        int
    ConsecutiveFailures int
    State               CircuitBreakerState
    LastFailTime        time.Time
}
```

## âœ… æœŸå¾…ã•ã‚Œã‚‹æŒ™å‹• (Expected Behavior)

æ­£ã—ãå®Ÿè£…ã•ã‚ŒãŸCircuit Breakerã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å‹•ä½œã—ã¾ã™ï¼š

### ClosedçŠ¶æ…‹ã§ã®å‹•ä½œ
```
Request -> [CB: Closed] -> External Service -> Success/Failure
å¤±æ•—å›æ•°ãŒé–¾å€¤æœªæº€: ãã®ã¾ã¾å‡¦ç†ç¶™ç¶š
å¤±æ•—å›æ•°ãŒé–¾å€¤åˆ°é”: OpençŠ¶æ…‹ã«ç§»è¡Œ
```

### OpençŠ¶æ…‹ã§ã®å‹•ä½œ
```
Request -> [CB: Open] -> Immediate Failure (ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œ)
ä¸€å®šæ™‚é–“çµŒé: Half-OpençŠ¶æ…‹ã«ç§»è¡Œ
```

### Half-OpençŠ¶æ…‹ã§ã®å‹•ä½œ
```
Request -> [CB: Half-Open] -> External Service (é™å®šçš„)
æˆåŠŸ: ClosedçŠ¶æ…‹ã«å¾©å¸°
å¤±æ•—: OpençŠ¶æ…‹ã«æˆ»ã‚‹
```

## ğŸ’¡ ãƒ’ãƒ³ãƒˆ (Hints)

1. **çŠ¶æ…‹ç®¡ç†**: `sync.RWMutex`ã‚’ä½¿ç”¨ã—ã¦ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ãªçŠ¶æ…‹ç®¡ç†ã‚’è¡Œã„ã¾ã—ã‚‡ã†
2. **æ™‚é–“ç®¡ç†**: `time.Since()`ã‚’ä½¿ç”¨ã—ã¦ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’åˆ¤å®šã—ã¾ã—ã‚‡ã†
3. **çµ±è¨ˆç®¡ç†**: æˆåŠŸãƒ»å¤±æ•—ã®ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’é©åˆ‡ã«æ›´æ–°ã—ã¾ã—ã‚‡ã†
4. **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°**: Circuit BrekerãŒé–‹ã„ã¦ã„ã‚‹å ´åˆã®å°‚ç”¨ã‚¨ãƒ©ãƒ¼ã‚’å®šç¾©ã—ã¾ã—ã‚‡ã†
5. **ãƒ†ã‚¹ã‚¿ãƒ“ãƒªãƒ†ã‚£**: æ™‚é–“ã«ä¾å­˜ã™ã‚‹å‡¦ç†ã¯å¤–éƒ¨ã‹ã‚‰åˆ¶å¾¡å¯èƒ½ã«ã—ã¾ã—ã‚‡ã†

## å‚è€ƒå®Ÿè£…ä¾‹

### åŸºæœ¬çš„ãªä½¿ç”¨ä¾‹

```go
// ã€åŸºæœ¬è¨­å®šã€‘å°è¦æ¨¡ã‚µãƒ¼ãƒ“ã‚¹å‘ã‘ã®è¨­å®šä¾‹
cb := NewCircuitBreaker(Settings{
    MaxFailures:      3,                // 3å›é€£ç¶šå¤±æ•—ã§OpençŠ¶æ…‹ã«ç§»è¡Œ
    ResetTimeout:     5 * time.Second,  // 5ç§’å¾Œã«HalfOpençŠ¶æ…‹ã§å›å¾©è©¦è¡Œ
    HalfOpenMaxCalls: 2,                // HalfOpençŠ¶æ…‹ã§æœ€å¤§2å›è©¦è¡Œ
})

// ã€å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹å‘¼ã³å‡ºã—ã®ãƒ©ãƒƒãƒ—ã€‘
result, err := cb.Call(func() (interface{}, error) {
    return externalServiceCall()
})
```

### å®Ÿç”¨çš„ãªå®Ÿè£…ä¾‹

```go
// ã€HTTPã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆç”¨Circuit Breakerã€‘ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³å¯¾å¿œ
type HTTPServiceClient struct {
    client         *http.Client
    circuitBreaker *CircuitBreaker
    baseURL        string
}

func NewHTTPServiceClient(baseURL string) *HTTPServiceClient {
    return &HTTPServiceClient{
        client: &http.Client{
            Timeout: 10 * time.Second,
        },
        circuitBreaker: NewCircuitBreaker(Settings{
            MaxFailures:      5,                // ä¿¡é ¼æ€§ã®é«˜ã„ã‚µãƒ¼ãƒ“ã‚¹æƒ³å®š
            ResetTimeout:     30 * time.Second, // ååˆ†ãªå›å¾©æ™‚é–“
            HalfOpenMaxCalls: 3,                // æ®µéšçš„å›å¾©
        }),
        baseURL: baseURL,
    }
}

func (c *HTTPServiceClient) GetUser(userID int) (*User, error) {
    // ã€Circuit BreakerçµŒç”±ã§ã®å®‰å…¨ãªå‘¼ã³å‡ºã—ã€‘
    result, err := c.circuitBreaker.Call(func() (interface{}, error) {
        return c.fetchUser(userID)
    })
    
    if err != nil {
        // ã€ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã€‘Circuit Breakerç‰¹æœ‰ã®ã‚¨ãƒ©ãƒ¼ã‚‚è€ƒæ…®
        if cbErr, ok := err.(*CircuitBreakerError); ok {
            log.Printf("Circuit breaker error: %s", cbErr.Message)
            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†ã‚„ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰ã®å–å¾—
            return c.getUserFromCache(userID)
        }
        return nil, err
    }
    
    user, ok := result.(*User)
    if !ok {
        return nil, fmt.Errorf("unexpected response type")
    }
    
    return user, nil
}

func (c *HTTPServiceClient) fetchUser(userID int) (*User, error) {
    url := fmt.Sprintf("%s/users/%d", c.baseURL, userID)
    resp, err := c.client.Get(url)
    if err != nil {
        return nil, fmt.Errorf("HTTP request failed: %w", err)
    }
    defer resp.Body.Close()
    
    if resp.StatusCode >= 500 {
        // ã€5xxç³»ã‚¨ãƒ©ãƒ¼ã€‘Circuit Breakerã«ã‚ˆã‚‹ä¿è­·å¯¾è±¡
        return nil, fmt.Errorf("server error: %d", resp.StatusCode)
    }
    
    if resp.StatusCode == 404 {
        // ã€4xxç³»ã‚¨ãƒ©ãƒ¼ã€‘Circuit Breakerã‚’å‹•ä½œã•ã›ãªã„æ¥­å‹™ã‚¨ãƒ©ãƒ¼
        return nil, fmt.Errorf("user not found")
    }
    
    var user User
    if err := json.NewDecoder(resp.Body).Decode(&user); err != nil {
        return nil, fmt.Errorf("JSON decode failed: %w", err)
    }
    
    return &user, nil
}
```

### ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã§ã®ä½¿ç”¨ä¾‹

```go
// ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç”¨Circuit Breakerã€‘é«˜å¯ç”¨æ€§å¯¾å¿œ
type DatabaseService struct {
    db             *sql.DB
    circuitBreaker *CircuitBreaker
    cache          *Cache // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥
}

func NewDatabaseService(db *sql.DB) *DatabaseService {
    return &DatabaseService{
        db: db,
        circuitBreaker: NewCircuitBreaker(Settings{
            MaxFailures:      10,               // DBæ¥ç¶šã¯æ¯”è¼ƒçš„å®‰å®šæƒ³å®š
            ResetTimeout:     60 * time.Second, // DBå¾©æ—§ã«ã¯æ™‚é–“ãŒã‹ã‹ã‚‹å ´åˆãŒå¤šã„
            HalfOpenMaxCalls: 1,                // æ…é‡ãªå›å¾©åˆ¤å®š
        }),
        cache: NewCache(),
    }
}

func (ds *DatabaseService) GetOrder(orderID int) (*Order, error) {
    // ã€Circuit BreakerçµŒç”±ã§ã®DBæ“ä½œã€‘
    result, err := ds.circuitBreaker.Call(func() (interface{}, error) {
        return ds.queryOrder(orderID)
    })
    
    if err != nil {
        // ã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã€‘ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã¾ãŸã¯èª­ã¿å–ã‚Šå°‚ç”¨ãƒ¬ãƒ—ãƒªã‚«ã‹ã‚‰å–å¾—
        if cbErr, ok := err.(*CircuitBreakerError); ok {
            log.Printf("Database circuit breaker activated: %s", cbErr.Message)
            return ds.getOrderFromCache(orderID)
        }
        return nil, err
    }
    
    order := result.(*Order)
    
    // ã€æˆåŠŸæ™‚ã€‘ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
    ds.cache.Set(fmt.Sprintf("order:%d", orderID), order, 5*time.Minute)
    
    return order, nil
}
```

### è¤‡æ•°Circuit Breakerã®çµ„ã¿åˆã‚ã›

```go
// ã€ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹é–“é€šä¿¡ã€‘è¤‡æ•°ã®Circuit Breakerç®¡ç†
type ServiceRegistry struct {
    userService    *CircuitBreaker
    orderService   *CircuitBreaker
    paymentService *CircuitBreaker
}

func NewServiceRegistry() *ServiceRegistry {
    return &ServiceRegistry{
        // ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚µãƒ¼ãƒ“ã‚¹ã€‘é«˜é »åº¦ãƒ»ä½é‡è¦åº¦
        userService: NewCircuitBreaker(Settings{
            MaxFailures:      3,
            ResetTimeout:     10 * time.Second,
            HalfOpenMaxCalls: 2,
        }),
        
        // ã€æ³¨æ–‡ã‚µãƒ¼ãƒ“ã‚¹ã€‘ä¸­é »åº¦ãƒ»ä¸­é‡è¦åº¦
        orderService: NewCircuitBreaker(Settings{
            MaxFailures:      5,
            ResetTimeout:     30 * time.Second,
            HalfOpenMaxCalls: 3,
        }),
        
        // ã€æ±ºæ¸ˆã‚µãƒ¼ãƒ“ã‚¹ã€‘ä½é »åº¦ãƒ»é«˜é‡è¦åº¦
        paymentService: NewCircuitBreaker(Settings{
            MaxFailures:      8,
            ResetTimeout:     60 * time.Second,
            HalfOpenMaxCalls: 1,
        }),
    }
}

func (sr *ServiceRegistry) ProcessOrder(order *Order) error {
    // ã€STEP 1ã€‘ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã®å–å¾—ï¼ˆå¤±æ•—ã—ã¦ã‚‚ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã§ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å¯èƒ½ï¼‰
    _, err := sr.userService.Call(func() (interface{}, error) {
        return getUserInfo(order.UserID)
    })
    if err != nil {
        log.Printf("User service unavailable, using cached data: %v", err)
    }
    
    // ã€STEP 2ã€‘æ³¨æ–‡ã®ä½œæˆï¼ˆå¿…é ˆå‡¦ç†ï¼‰
    _, err = sr.orderService.Call(func() (interface{}, error) {
        return createOrder(order)
    })
    if err != nil {
        return fmt.Errorf("order creation failed: %w", err)
    }
    
    // ã€STEP 3ã€‘æ±ºæ¸ˆå‡¦ç†ï¼ˆæœ€ã‚‚é‡è¦ï¼‰
    _, err = sr.paymentService.Call(func() (interface{}, error) {
        return processPayment(order.PaymentInfo)
    })
    if err != nil {
        // ã€è£œå„Ÿå‡¦ç†ã€‘æ³¨æ–‡ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
        cancelOrder(order.ID)
        return fmt.Errorf("payment failed: %w", err)
    }
    
    return nil
}
```

### ç›£è¦–ã¨ãƒ¡ãƒˆãƒªã‚¯ã‚¹

```go
// ã€ç›£è¦–æ©Ÿèƒ½ä»˜ãCircuit Breakerã€‘é‹ç”¨ç›£è¦–å¯¾å¿œ
type MonitoredCircuitBreaker struct {
    *CircuitBreaker
    metrics *MetricsCollector
    name    string
}

func NewMonitoredCircuitBreaker(name string, settings Settings) *MonitoredCircuitBreaker {
    return &MonitoredCircuitBreaker{
        CircuitBreaker: NewCircuitBreaker(settings),
        metrics:        NewMetricsCollector(),
        name:          name,
    }
}

func (mcb *MonitoredCircuitBreaker) Call(fn func() (interface{}, error)) (interface{}, error) {
    start := time.Now()
    
    result, err := mcb.CircuitBreaker.Call(fn)
    
    duration := time.Since(start)
    
    // ã€ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†ã€‘
    mcb.metrics.RecordCall(mcb.name, duration, err)
    
    // ã€çŠ¶æ…‹å¤‰åŒ–ã®æ¤œå‡ºã¨ã‚¢ãƒ©ãƒ¼ãƒˆã€‘
    if mcb.GetState() == StateOpen {
        mcb.metrics.RecordCircuitBreakerOpen(mcb.name)
        
        // ã€ã‚¢ãƒ©ãƒ¼ãƒˆé€ä¿¡ã€‘é‹ç”¨ãƒãƒ¼ãƒ ã¸ã®é€šçŸ¥
        sendAlert(fmt.Sprintf("Circuit breaker '%s' is OPEN", mcb.name))
    }
    
    return result, err
}

func (mcb *MonitoredCircuitBreaker) GetHealthStatus() map[string]interface{} {
    counts := mcb.GetCounts()
    
    return map[string]interface{}{
        "name":                mcb.name,
        "state":               counts.State.String(),
        "total_calls":         counts.TotalCalls,
        "success_rate":        float64(counts.SuccessCalls) / float64(counts.TotalCalls),
        "consecutive_failures": counts.ConsecutiveFailures,
        "last_failure":        counts.LastFailTime,
    }
}
```

## ã‚¹ã‚³ã‚¢ã‚«ãƒ¼ãƒ‰

- âœ… åŸºæœ¬å®Ÿè£…: 3ã¤ã®çŠ¶æ…‹ãŒæ­£ã—ãå‹•ä½œã™ã‚‹
- âœ… ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•: ä¸¦è¡Œã‚¢ã‚¯ã‚»ã‚¹ã§æ­£ã—ãå‹•ä½œã™ã‚‹
- âœ… çµ±è¨ˆç®¡ç†: å¤±æ•—ç‡ãŒæ­£ã—ãè¨ˆç®—ã•ã‚Œã‚‹
- âœ… è‡ªå‹•å›å¾©: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå¾Œã®è‡ªå‹•å›å¾©ãŒå‹•ä½œã™ã‚‹
- âœ… ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: OpençŠ¶æ…‹ã§é©åˆ‡ã«å¤±æ•—ã™ã‚‹

## å®Ÿè¡Œæ–¹æ³•

```bash
go test -v
go test -race
go test -bench=.
```

## å‚è€ƒè³‡æ–™

- [Circuit Breaker Pattern - Martin Fowler](https://martinfowler.com/bliki/CircuitBreaker.html)
- [Hystrix Documentation](https://github.com/Netflix/Hystrix/wiki)
- [Go Concurrency Patterns](https://blog.golang.org/concurrency-patterns)